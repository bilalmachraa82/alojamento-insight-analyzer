/**
 * Image Loader Utility
 *
 * Provides functions to optimize image loading with:
 * - Responsive image srcset generation
 * - Multiple format support (AVIF, WebP, JPEG/PNG)
 * - Cloudflare Images integration ready
 * - Dynamic sizing for different viewports
 *
 * Usage:
 * ```tsx
 * const srcSet = generateSrcSet('/path/to/image.jpg', [320, 640, 1024]);
 * const cloudflareUrl = buildCloudflareImageUrl('image-id', { width: 800, format: 'webp' });
 * ```
 */

/**
 * Supported image widths for responsive images
 * Optimized for common breakpoints: mobile, tablet, desktop
 */
export const IMAGE_WIDTHS = [320, 640, 768, 1024, 1280, 1536, 1920] as const;

/**
 * Supported modern image formats
 * Order matters: AVIF (best compression) → WebP → original format
 */
export const IMAGE_FORMATS = ['avif', 'webp', 'jpg', 'png'] as const;

export type ImageFormat = typeof IMAGE_FORMATS[number];
export type ImageWidth = typeof IMAGE_WIDTHS[number];

/**
 * Configuration for Cloudflare Images
 * Set VITE_CLOUDFLARE_IMAGES_URL in .env for production
 */
const CLOUDFLARE_IMAGES_ACCOUNT_HASH = import.meta.env.VITE_CLOUDFLARE_IMAGES_ACCOUNT_HASH || '';
const CLOUDFLARE_IMAGES_ENABLED = import.meta.env.VITE_CLOUDFLARE_IMAGES_ENABLED === 'true';

/**
 * Options for image transformation
 */
export interface ImageTransformOptions {
  width?: number;
  height?: number;
  quality?: number; // 1-100, default 85
  format?: ImageFormat;
  fit?: 'scale-down' | 'contain' | 'cover' | 'crop' | 'pad';
}

/**
 * Generates a srcset string for responsive images
 *
 * @param src - Original image source URL
 * @param widths - Array of widths to generate (defaults to IMAGE_WIDTHS)
 * @param format - Target format (optional, uses original if not specified)
 * @returns srcset string ready for <img> or <source> tag
 *
 * @example
 * ```tsx
 * generateSrcSet('/images/hero.jpg', [640, 1024, 1280])
 * // Returns: '/images/hero-640w.jpg 640w, /images/hero-1024w.jpg 1024w, /images/hero-1280w.jpg 1280w'
 * ```
 */
export function generateSrcSet(
  src: string,
  widths: readonly number[] = IMAGE_WIDTHS,
  format?: ImageFormat
): string {
  // If Cloudflare Images is enabled, use it for srcset generation
  if (CLOUDFLARE_IMAGES_ENABLED && CLOUDFLARE_IMAGES_ACCOUNT_HASH) {
    return widths
      .map((width) => {
        const url = buildCloudflareImageUrl(src, { width, format });
        return `${url} ${width}w`;
      })
      .join(', ');
  }

  // Fallback: Generate local URLs with width suffixes
  // In production, these would be generated by your build process or CDN
  return widths
    .map((width) => {
      const url = getResponsiveImageUrl(src, width, format);
      return `${url} ${width}w`;
    })
    .join(', ');
}

/**
 * Generates a responsive image URL for a given width
 * This is a placeholder - in production, you'd have actual optimized images
 *
 * @param src - Original image source
 * @param width - Target width
 * @param format - Target format
 * @returns Transformed URL
 */
export function getResponsiveImageUrl(
  src: string,
  width: number,
  format?: ImageFormat
): string {
  // For external URLs (Unsplash, etc), append query parameters
  if (src.startsWith('http://') || src.startsWith('https://')) {
    const url = new URL(src);
    url.searchParams.set('w', width.toString());
    url.searchParams.set('q', '85');
    if (format === 'webp') {
      url.searchParams.set('fm', 'webp');
    } else if (format === 'avif') {
      url.searchParams.set('fm', 'avif');
    }
    return url.toString();
  }

  // For local images, use the original path
  // In a real implementation, you'd have optimized versions generated
  const ext = format || getFileExtension(src);
  const pathWithoutExt = src.replace(/\.[^.]+$/, '');
  return `${pathWithoutExt}-${width}w.${ext}`;
}

/**
 * Builds a Cloudflare Images URL with transformations
 *
 * @param imageId - Image ID or path in Cloudflare Images
 * @param options - Transformation options
 * @returns Cloudflare Images URL with transformations
 *
 * @example
 * ```tsx
 * buildCloudflareImageUrl('hero-image', { width: 800, format: 'webp', quality: 85 })
 * // Returns: 'https://imagedelivery.net/{hash}/hero-image/w=800,f=webp,q=85'
 * ```
 */
export function buildCloudflareImageUrl(
  imageId: string,
  options: ImageTransformOptions = {}
): string {
  if (!CLOUDFLARE_IMAGES_ENABLED || !CLOUDFLARE_IMAGES_ACCOUNT_HASH) {
    // Return original URL if Cloudflare Images is not configured
    return imageId;
  }

  const {
    width,
    height,
    quality = 85,
    format = 'auto',
    fit = 'scale-down',
  } = options;

  // Build transformation string
  const transforms: string[] = [];

  if (width) transforms.push(`w=${width}`);
  if (height) transforms.push(`h=${height}`);
  transforms.push(`q=${quality}`);
  if (format !== 'auto') transforms.push(`f=${format}`);
  transforms.push(`fit=${fit}`);

  const transformString = transforms.join(',');

  // Cloudflare Images URL format:
  // https://imagedelivery.net/{account_hash}/{image_id}/{variant_name}
  return `https://imagedelivery.net/${CLOUDFLARE_IMAGES_ACCOUNT_HASH}/${imageId}/${transformString}`;
}

/**
 * Generates sizes attribute for responsive images
 *
 * @param breakpoints - Object mapping viewport sizes to image widths
 * @returns sizes string for <img> tag
 *
 * @example
 * ```tsx
 * generateSizes({
 *   sm: '100vw',
 *   md: '50vw',
 *   lg: '33vw',
 *   default: '800px'
 * })
 * // Returns: '(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 800px'
 * ```
 */
export function generateSizes(breakpoints: {
  sm?: string;
  md?: string;
  lg?: string;
  xl?: string;
  default: string;
}): string {
  const sizes: string[] = [];

  if (breakpoints.sm) sizes.push(`(max-width: 640px) ${breakpoints.sm}`);
  if (breakpoints.md) sizes.push(`(max-width: 768px) ${breakpoints.md}`);
  if (breakpoints.lg) sizes.push(`(max-width: 1024px) ${breakpoints.lg}`);
  if (breakpoints.xl) sizes.push(`(max-width: 1280px) ${breakpoints.xl}`);

  sizes.push(breakpoints.default);

  return sizes.join(', ');
}

/**
 * Detects if the browser supports a specific image format
 * Uses feature detection to determine support
 *
 * @param format - Image format to check
 * @returns Promise that resolves to boolean
 */
export async function supportsImageFormat(format: ImageFormat): Promise<boolean> {
  // Check if we're in a browser environment
  if (typeof window === 'undefined') return false;

  // Check for cached result
  const cacheKey = `supports_${format}`;
  const cached = sessionStorage.getItem(cacheKey);
  if (cached !== null) return cached === 'true';

  // Create test image for format detection
  const testImages: Record<ImageFormat, string> = {
    avif: 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',
    webp: 'data:image/webp;base64,UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',
    jpg: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/wA==',
    png: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==',
  };

  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const supported = img.width > 0 && img.height > 0;
      sessionStorage.setItem(cacheKey, String(supported));
      resolve(supported);
    };
    img.onerror = () => {
      sessionStorage.setItem(cacheKey, 'false');
      resolve(false);
    };
    img.src = testImages[format];
  });
}

/**
 * Gets the best supported format from a list of formats
 *
 * @param formats - Array of formats to check (in order of preference)
 * @returns Promise resolving to the best supported format
 */
export async function getBestSupportedFormat(
  formats: readonly ImageFormat[] = IMAGE_FORMATS
): Promise<ImageFormat> {
  for (const format of formats) {
    if (await supportsImageFormat(format)) {
      return format;
    }
  }
  // Fallback to jpg if nothing is supported (shouldn't happen)
  return 'jpg';
}

/**
 * Extracts file extension from a path or URL
 *
 * @param path - File path or URL
 * @returns File extension without the dot
 */
export function getFileExtension(path: string): string {
  const match = path.match(/\.([^.?#]+)(?:[?#]|$)/);
  return match ? match[1] : 'jpg';
}

/**
 * Creates a blur placeholder data URL for better perceived performance
 * This is a simple implementation - in production you might use BlurHash or similar
 *
 * @param width - Placeholder width
 * @param height - Placeholder height
 * @param color - Background color (hex)
 * @returns Data URL for blur placeholder
 */
export function createBlurPlaceholder(
  width: number = 10,
  height: number = 10,
  color: string = '#e5e7eb'
): string {
  // For production, you'd typically generate actual blur hashes from your images
  // This is a simple SVG placeholder
  const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">
      <filter id="blur">
        <feGaussianBlur stdDeviation="2"/>
      </filter>
      <rect width="${width}" height="${height}" fill="${color}" filter="url(#blur)"/>
    </svg>
  `;

  return `data:image/svg+xml;base64,${btoa(svg)}`;
}

/**
 * Optimized image loading configuration
 */
export const IMAGE_LOADING_CONFIG = {
  // Quality settings for different formats
  quality: {
    avif: 80,
    webp: 85,
    jpg: 85,
    png: 100, // PNG is lossless, quality doesn't apply
  },

  // Default sizes for common use cases
  defaultSizes: {
    hero: generateSizes({ sm: '100vw', md: '100vw', lg: '50vw', default: '1280px' }),
    card: generateSizes({ sm: '100vw', md: '50vw', lg: '33vw', default: '400px' }),
    thumbnail: generateSizes({ sm: '100vw', md: '25vw', lg: '20vw', default: '200px' }),
    fullWidth: '100vw',
  },
} as const;
